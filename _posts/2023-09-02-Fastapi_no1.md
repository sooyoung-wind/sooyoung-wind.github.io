---
layout: post
title: FastAPI에 대해서
tags: [FastAPI, python]
categories: [FastAPI, python]
sitemap:
  changefreq: daily
  priority : 1.0
# thumbnail: "/assets/img/kaggle/0001.png"
---
오늘은 FastAPI에 대해서 공부하고자 한다. python에서 사용할 수 있는 API는 Flask, Django, FastAPI가 있다. API(Application Programming Interface)란 소프트웨어 컴포넌트 간에 상호작용 하는 방법을 정의한 집합적인 규칙과 규악을 말한다. API는 서로 다른 소프트웨어 시스템 간에 데이터를 주고받거나 서비스를 호출하기 위한 표준화된 인터페이스를 제공하여 많은 영역에서 사용되고 있다. 나도 배우고자 하는 이유이다.  

간단하게 설명하면 내가 운영하고 있는 서버와 앱 어플리케이션간의 통신을 하는 규칙을 API를 통해 정의할 수 있다. 또한 서버에서 특정 작업을 하기 위해서 API를 사용할 수 있기 때문이다.  


목차
- toc
{: toc }


----
+ **Flask**  
**1. 가벼움** : Flask는 미니멀한 디자인과 필요한 기능한 포함하고 있으므로 런타임 오버헤드가 적고 작은 프로젝트나 마이크로 서비스에 적합하다.  
**2. 유연성** : Flask는 개발에게 높은 유연성을 제공하며, 원하는 방식으로 애플리케이션을 구성할 수 있다.  
**3. 확장성** : Flask의 확장성은 플러그인과 확장을 통해 제공되며, 필요한 기능을 추가하기 쉽다.  
**4. 커뮤니티와 문서** : 활발한 커뮤니티와 풍부한 문서를 가지고 있어 학습 및 지원이 용이하다.  

단점으로는  
1. 기본 기능 부족 : 기본적으로 많은 기능을 제공하지 않으며, 개발자가 직접 필요한 모든 기능을 구현해야 하는 단점이 있다.  
2. 대규모 프로젝트 : 대규모 및 복잡한 프로젝트에서는 Django나 FastAPI보다 부적합할 수 있다.  

----
+ **Django**  
**1. 원전한 프레임워크** : Django는 기본적으로 데이터베이스 연동, 사용자 인증, 관리자 패널 등 많은 기능을 제공하여 빠른 개발이 가능하다.  
**2. 보안** : 보안에 대한 다양한 기능을 기본적으로 제공하므로 보안 이슈를 줄이는 데 도움이 된다.  
**3. 커뮤니티와 패키지** : 큰 커뮤니티와 다양한 패키지를 가지고 있어 다양한 작업을 쉽게 처리할 수 있다.  

단점으로는  
1. 무겁고 복잡함 : 모든 기능을 포함하고 있기 때문에 작은 프로젝트나 마이크로 서비스에서는 과도한 오버해드가 발생할 수 있다.  
2. 학습 곡선 : Django의 학습 곡선은 상대적으로 높으며, 초보자에게는 적극하기에 많은 어려움이 존재한다.  

----
+ **FastAPI**  
**1. 빠른 속도** : FastAPI는 빠른 속도로 웹 애플리케이션을 개발할 수 있도록 설계되었다.  
**2. 현대적인 API 지원** : API개발에 특화되어 있으며, 자동 문서화 및 유형 어노테이션을 활용한 강력한 API지원을 제공한다.  
**3. 뛰어난 성능** : 비동기 지원을 통해 뛰어난 성능을 제공하며, 대규모 데이터 처리에도 적합하다.  

단점으로는  
1. 상대적으로 새로운 프레임워크로 비교적 새로운 프레임워크이미 때문에 Django나 Flask보다는 커뮤니티와 패키지 생태계가 더 작을 수 있다.  
2. 학습 곡선 : FastAPI의 현대적인 기능을 활용하려면 Python 및 웹 개발에 대한 기본 지식이 필요하다.  

----  

나는 최종적으로 FastAPI를 선택했다. 딱히 경험이 있는건 아니지만, Django는 너무 무겁고 진입 장벽이 있었고, Flask는 쉬우나 범용성이 떨어져 보였다. 솔직히 당장 도입하고 사용하기엔 Flask가 좋았지만, 강의가 있으니 FastAPI를 공부해 보기로 했다.  


&nbsp;
----
### FastAPI 설치 및 구동  

`pip install fastapi`설치 방법은 이와 같고 기본적인 Hello World! 구현 방법은 아래와 같다.  
```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def hello():
    return "Hello, World!"
```
하지만, 실행하면 아무 반응이 없다. 이는 각 프레임워크마다 개발서버를 내장하고 있는데 초보자 개발자들이 개발용 서버를 상용 배포를 하는 실수를 해버리는 경우가 많아 FastAPI는 개발 서버를 과감히 빼버렸다. 그래서 FastAPI를 구동할려면 `Uvicorn`을 설치하여 구동해야 한다. `Hypercorn`도 있지만, 강의에서 uvicorn을 사용하고 있기 때문에 uvicorn을 사용하기로 했다.  

설치 방법 : `pip install uvicorn` or `conda install uvicorn`  

실행 방법 : `uvicorn main:app --reload`

python 코드에서 실행되게 할려면 아래와 같이 작성하면 된다.  
```python
import uvicorn
from fastapi import FastAPI

app = FastAPI()

@app.get("/")
def hello():
    return "Hello, World!"

if __name__ == "__main__":
    uvicorn.run("main:app", reload=True)
```


&nbsp;
----
### httpie  
API 개발에 사용되는 도구는 다양하다.  
+ curl
+ wget
+ [Postman](https://www.postman.com/) 또는 [Insomnia](https://insomnia.rest/)
+ VScode extension - [REST Client](https://marketplace.visualstudio.com/items?itemName=humao.rest-client)
+ etc...

강의에서 사용되는 도구는 [httpie](https://httpie.io/)라고 `conda install httpie or pip install httpie`로 설치 가능한 도구이다.  
httpie의 실행방법은 명령 프롬프트에서 `http locahost:8000 또는 http :8000`로 실행할 수 있다. 당연히 위의 
```
python main.py
```
코드를 실행한 후에 가능하다.  


&nbsp;
----
### 경로 매개변수  

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"user_id": user_id}
```

`http :8000/users/123`이라고 프롬프트에 입력하면 `return`구문이 출력된다.  

&nbsp;

----
### 순서 문제  

FastAPI의 단점은 중 하나로 순서에 문제가 있다. 아래 코드에서 app.get에 입력된 경로가 `@app.get("/users/{user_id}")` 다음에 `@app.get("/users/last")`로 구성되어 있으면 앞에 경로는 잘 실행되나 뒤에 있는 `last`는 실행이 안된다. 이는 앞에 있는 `user_id`에 먼저 들어가버리기 때문이다.

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"user_id": user_id}

# 추가: 현재 유저를 반환하는 앤드포인트
@app.get("/users/last")
def get_current_user():
    return {"user_id": 798}
```

따라서 API 서버를 실행하는데 일부 경로가 실행이 안된다면 순서에 문제가 있는지 확인을 해야 한다. 올바른 방법은 아래와 같이 순서만 변경하면 된다.  

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/users/last")
def get_current_user():
    return {"user_id": 798}

@app.get("/users/{user_id}")
def get_user(user_id: int):
    return {"user_id": user_id}

```

&nbsp;

----

### 쿼리 매개변수  

`https://api_url.com?page=1&num=100`와 같이 `?`뒤에 오는 변수들을 쿼리 매개변수(Query parameters)라 부른다. 각 매개변수는 `&`기호로 구분되고 `key=value`와 같이 키:값 쌍으로 정의된다.(python의 딕셔너리 형태로 보임)  

```python
from fastapi import FastAPI

app = FastAPI()

@app.get("/users")
def get_users(limit: int):
    return {"limit": limit}
```

경로 매개변수와 달리 `get_users`함수안에 사용되는 매개변수를 쿼리로 받을 수 있다.   

```
http 'localhost:8000/users?limit=100'
```  

&nbsp;

----

### 문자열 열거형  

열거체(Enumeration) 사용법  

```python
from enum import Enum # enum 호출
from fastapi import FastAPI

app = FastAPI()

# enum을 사용하는 class 선언
class UserLevel(str, Enum):
    a = "a"
    b = "b"
    c = "c"

@app.get("/users")
def get_users(grade: UserLevel):
    return {"grade": grade}
```

위와 같이 작성하면 `grade`는 `a`, `b`, 'c' 중에서만 입력이 가능하다. 만약 정의하지 않은 값으로 호출하면 입력이 가능한 값이 무엇인지 알려준다.  
그리고 만약 `UserLevel`에 선언된 매개변수를 기본 값으로 선언하고 싶어서 `UserLevel.a` 와 같이 작성했지만, 추후에 `a`가 삭제된다면 `enum`에 없는 매개변수를 불러오기 때문에 컴파일러 또는 배포가 안된다.  
이 개념은 다른 언어에서도 동일하다.  



&nbsp;

----

### 요청하기  

POST, PUT, PATCH 등의 메소드를 사용하는 경우에 HTTP 본문(body)를 많이 사용한다. 단순 텍스트나 XML로도 보낼 수 있지만 요즘은 JSON을 이용하는 추세이다.  

**Pydantic으로 요청 본문(Request body) 받기**  
```python
import uvicorn
from typing import Optional

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

class User(BaseModel):
    name: str
    password: str
    avatar_url: Optional[HttpUrl] = None # HttpUrl는 url를 검증해 준다.

@app.post("/users")
def create_user(user: User):
    return user

if __name__ == "__main__":
    uvicorn.run("main:app", reload=True)
```

User 클래스는 `pydantic.BaseModel`을 상속하는 모델이다.([사이트 링크](https://docs.pydantic.dev/latest/usage/models/)를 통해서 문서를 확인해보자.)

> 비밀번호는 받드시 암호화해야 함으로 위와 같이 입력하면 절대로 안된다.  

```
http :8000/users name=sooy password=1234
```

`from pydantic import EmailStr`을 통해서 email 주소에 대한 검증을 할 수 있다.(자세하게 설명을 안해서 추가적인 공부가 필요함)  

아래 예시는 정규표현식을 사용해서 email 주소를 검증하는 방법이다.  
```python
import re

pattern = r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"
email_regex = re.compile(pattern)
email_regex.match("sooy")
email_regex.match("sooy@")
email_regex.match("sooy@gmail")
email_regex.match("sooy@gmail.com")
<re.Match object; span=(0, 22), match='sooy@gmail.com'>
```


&nbsp;

----


### 응답 모델  

응답 모델(Response Model)을 만들어보자.  

```python
from typing import Optional

from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

class User(BaseModel):
    name: str
    password: str
    avatar_url: Optional[HttpUrl] = None

# response_model이라는 매개변수에 User 클래스를 입력하여 응답이 오는지 확인할 수 있다.
@app.get("/users/me", response_model=User)
def get_user(user: User):
    return user
```
&nbsp;  
실제로 API를 호출하기 전에 아래 그림와 같이 응답을 확인할 수 있다.  

![그림](/assets/img/my_photo/fastapi_0001.png)



&nbsp;  

응답 모델을 class로 분리하여 선언했다. 이렇게 되면 응답에서 password를 숨길 수 있다. (그래도 암호화는 필수)


```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

class User(BaseModel):
    name: str
    avatar_url: HttpUrl = "https://icotar.com/avatar/fastcampus.png?s=200"

# 오직 passowrd만 변수 선언함
# User class에서 상속을 받기 때문에 name과 avatar_url를 선언하지 않았다.
# 중복 코드를 제거하고 코드의 재사용성을 높일 수 있는 방법이다.
class CreateUser(User):
    password: str

@app.post("/users", response_model=User)
def create_user(user: CreateUser):
    return user
```

#### 응답 코드 내용 수정  

유저의 실수로 발생되는 404 error와 같은 응답 결과를 직접 작성하여 제공할 수 있다. 각 상태코드에 대한 정보는 [위키백과](https://zrr.kr/3zN8) 또는 [mozilla 사이트(영문)](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)를 참고하면 된다.  

```python
from fastapi import FastAPI
from pydantic import BaseModel, HttpUrl

app = FastAPI()

class User(BaseModel):
    name: str
    avatar_url: HttpUrl = "https://icotar.com/avatar/fastcampus.png?s=200"

class CreateUser(User):
    password: str

@app.post("/users", response_model=User, status_code=201)  # 추가: status_code
def create_user(user: CreateUser):
    return user
```

조금 더 사용자가 읽을 수 있는 형태로 하고자 한다면 아래 `status`를 불러와서 사용하면 된다. 메소드 이름이 자동으로 구현된다는 뜻이다. 아래 그림으로 끝이다. 다만, 코드번호를 따로 찾지 않고 메소드 이름을 통해서 확인할 수 있어서 유용하다.  

```python
from fastapi import FastAPI, status
```

![그림](/assets/img/my_photo/fastapi_0002.png)

