---
layout: post
title: EDA 1일차 수강(python)
tags: [python EDA]
categories: [python EDA]
---
강의 내용 정리

목차
- toc
{: toc }

----
#### Numpy 모듈

Numpy는 C 언어로 작성되었기 대문에 빠른 성능을 보여준다. 수치 연산에 대한 안전성이 보장되어 있다.**(numerical stable)** N차원 벡터 연산에 최적화되어 있다.  

```python
# 딥러닝에서 무조건 쓰는 모듈
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as snss
```

numpy array는 numpy에서 사용되는 기본적인 자료 구조인데 리스트와 다르게 선언한 이후에 크기 변경이 불가능하고 모든 원소의 데이터 타입이 동일해야 한다.**(homogeneous array)** indexing으로 원소에 접근이 가능하다. 배열의 원소를 update할 수 있다.  

float32 - single precision  
float64 - double precision  

```python
data = [1,2,3,4]
data2 = [[1,2],
        [3,4]]

arr = np.array(data) # numpy array 선언
arr2 = np.array(data2)

# 기본 사용법
np.arange(0,10) # 0부터 9까지 생성
np.zeros(5) # 0인 값으로 배열 선언
np.zeros([2,2]) # 0인 값으로 2 x 2 배열 선언
np.ones(7) # 1인 값으로 배열 선언
np.empty(3) # 랜덤인 값으로 배열 선언
np.linspace(0, 50, 50) # 0부터 50까지 50등분해서 배열 선언

# Array Arithmetic (like vector)
v1 = np.array([1,2,3])
v2 = np.array([4,5,6])

# 리스트에서 합은 리스트의 concatenation이지만 numpy에서는 다르다.
v1 + v2 # 같은 위치에 있는 요소들 끼리 합을 구함
v1 - v2
v1 * v2
v1 / v2
v1 @ v2 # 벡터 내적
np.cross(v1, v2) # 벡터 외적

# Broadcast and Universal Function
# 서로 다른 크기를 가진 array를 연살 할 경우

arr1 = np.array([1,0,0])
arr2 = np.array([[1,2,3],
                [4,5,6]])

arr1 + arr2 # 배열 크기가 달라도 앞에 3이 같아서 가능..(?확실해?)

arr = np.array([1.,2.,3.,4.])
f = lambda x : 1/x
[f(ii) for ii in arr ]
# 위의 코딩을 아래 코드로 해결 됨
1/arr

# Fancy Indexing
arr1 = np.arange(10)

# 첫번째 원소
arr1[0]
# 마지막 원소
arr1[-1]
# 앞에서부터 원소 3개 slicing
arr1[:3]

arr2 = np.array([[1, 2, 3, 4],
               [5, 6, 7, 8],
               [9, 10, 11, 12]])
arr2.shape
# np.array.shape의 규칙 : 괄호 앞에서부터 제일 바깥 []의 원소의 개수부터 안쪽 []까지 차례대로 적는다.        

```


